%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 %
%                            CHAPTER                              %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Initial Difficulties during the implementation}

\textit{Disclaimer: The purpose of this chapter is more to show the learning process I had to go through in order to achieve a suitable implementation for the genome mapping problem. I had to learn some new programming techniques such as HLS, SDSoC \dots especially for this thesis, since I did not have any experience in it yet. This chapter might be less applicable if the reader is interested in the science and implementation approach of the genome mapping problem, but can be of interest if the reader is also new to the mentioned programming techniques.}

\section{Using Vivado HLS and Xilinx SDK}

\subsection{Learning HLS in examples}

As mentioned in the disclaimer, I am fairly new to HLS. Therefore, this section will go through the learning process. I've received all the materials I needed to have a rough understanding in HLS from Mr. Martinek, who teaches HLS at the Brno University of Technology. After working through the theory, I figured the labs I made are worth exploring in this thesis, since they contain most concepts of HLS.

\paragraph{Lab1: BASIC WORKFLOW} 
\begin{itemize}
	\item How to start a new project;
	\item What the difference is between a source and a test bench;
	\item The properties of the available IDE when designing in HLS;
	\item How to simulate the sources using the test benches;
	\item Generate Gantt charts and how to analyse them;
	\item Where to fiend the resulting VHDL code;
	\item What the co-simulation is and why it is used;
	\item Where to view the resulting simulation waveforms;
	\item How to export your design as an IP;
	\item It is possible to compare multiple solutions for a problem;
	\item How to set a directive (such as unrolling a loop).
\end{itemize}

\paragraph{lab2: EXPLORING DATA TYPES using an FIR filter}
\begin{itemize}
	\item When to use the floating point or fixed point representation;
	\item How to enable saturation when using fixed point;
	\item How to do calculations that normally would result in an overflow using fixed point. This can be done by lowering the resolution (dropping LSBs) so the result can still be stored in the same bit width.
\end{itemize}

\paragraph{lab3: INTERFACES} 
\begin{itemize}
	\item The basic argument-level interfaces and their differences, such as ap\_vld, ap\_none, and ap\_hs;
	\item A block-level interface of a pipelined component (pipeline in the top function).
\end{itemize}


\paragraph{lab4: ARRAYS}
\begin{itemize}
	\item Sequential running of a design;
	\item How to pipeline an internal loop;
	\item What a rewind parameter is;
	\item How to do top-function pipelining;
	\item The array-map technique;
	\item How to partition arrays (cyclic and complete);
	\item How to reshape arrays
\end{itemize}

\subsection{Learning how to program target board}

At first, before knowing the existence of the SDSoC IDE, the best way to program the board seemed by using the Xilinx SDK. I got as far as programming a hello world program, but in the end I switched to SDSoC when I discovered its easyness. The Xilinx SDK was just too unpractical to use, and the application would be baremetal, which would mean I would need to implement a FAT or Ethernet stack myself.

\section{SDSoC}

Op een Linuxdistributie.

Snel functie verplaatsen van PS naar PL.

gebruikt ook delen van HLS

\subsection{learning process on matrix multiplication example in SDSoC}

Eerste test: matrixmultiplicatie

lab1: INTRODUCTION: basic workflow, working with hardware accelerators, running the project, ...

lab2: PERFORMANCE ESTIMATION: rescource utilization, comparing software and hardware implementations, overall speedup comparison (all using LINUX hosted)

lab3: diff between ACP, AFI and GP
	ACP	Hardware functions have cache coherent access to DDR via the PS L2 cache.
	AFI (HP)	Hardware functions have fast non-cache coherent access to DDR via the PS memory controller.
	GP	Processor directly writes/reads data to/from hardware function. Inefficient for large data transfers.
+ error reporting (opening log files to see more information).
Additional: the hardware functions and DMAs can only access the physical address space (not virtual) => DMA that can handle a list of pages for a single array is known as Scatter-Gather DMA. (malloc(), sds\_alloc()) Typically sds\_alloc = best (area and performance) but uses physical memory (minder van beschikbaar dan virtueel).

lab4: directives to optimize the accelerator

lab5: task level pipelining
	=> speedup x3 theoretical, probably I make some mistakes

lab6: DEBUG

lab7: HARDWARE DEBUG: trace feature: what is the application doing? (software, hardware, transfer, recieve)

lab8: EMULATION
